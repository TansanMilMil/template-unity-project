using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace TansanMilMil.Util
{
    public static class ExportSceneDefinition
    {
        private const string OutputPathKey = "TansanMilMilUtil.SceneDefinition.OutputPath";

        [MenuItem("Tools/TansanMilMilUtil/ExportSceneDefinition/Export Scene Definition")]
        private static void Export()
        {
            string outputPath = GetOrSetOutputPath();
            if (string.IsNullOrEmpty(outputPath))
            {
                Debug.LogWarning("Scene definition export cancelled.");
                return;
            }

            GenerateSceneDefinitionFile(outputPath);
        }

        [MenuItem("Tools/TansanMilMilUtil/ExportSceneDefinition/Change Scene Definition Output Path")]
        private static void ChangeOutputPath()
        {
            string currentPath = EditorPrefs.GetString(OutputPathKey, "");
            string newPath = EditorUtility.SaveFilePanel(
                "Select output path for scene definitions",
                string.IsNullOrEmpty(currentPath) ? Application.dataPath : Path.GetDirectoryName(currentPath),
                "SceneDefinitions.cs",
                "cs"
            );

            if (!string.IsNullOrEmpty(newPath))
            {
                EditorPrefs.SetString(OutputPathKey, newPath);
                Debug.Log($"Scene definition output path changed to: {newPath}");
            }
        }

        private static string GetOrSetOutputPath()
        {
            string savedPath = EditorPrefs.GetString(OutputPathKey, "");

            if (string.IsNullOrEmpty(savedPath))
            {
                string defaultPath = EditorUtility.SaveFilePanel(
                    "Select output path for scene definitions",
                    Application.dataPath,
                    "SceneDefinitions.cs",
                    "cs"
                );

                if (!string.IsNullOrEmpty(defaultPath))
                {
                    EditorPrefs.SetString(OutputPathKey, defaultPath);
                    return defaultPath;
                }
                return null;
            }

            return savedPath;
        }

        private static void GenerateSceneDefinitionFile(string outputPath)
        {
            try
            {
                StringBuilder sb = new StringBuilder();

                sb.AppendLine("// Auto-generated scene definitions");
                sb.AppendLine("// Generated by TansanMilMilUtil ExportSceneDefinition");
                sb.AppendLine();
                sb.AppendLine("namespace TansanMilMil.Util");
                sb.AppendLine("{");
                sb.AppendLine("    public static class SceneDefinitions");
                sb.AppendLine("    {");

                // Get scene names from Unity's build settings
                EditorBuildSettingsScene[] scenes = EditorBuildSettings.scenes;
                int buildIndex = 0;

                foreach (EditorBuildSettingsScene scene in scenes)
                {
                    if (scene.enabled)
                    {
                        // Extract scene name from path
                        string sceneName = Path.GetFileNameWithoutExtension(scene.path);

                        if (!string.IsNullOrEmpty(sceneName))
                        {
                            // Convert scene name to valid C# identifier
                            string validName = MakeValidIdentifier(sceneName);
                            sb.AppendLine($"        public const string {validName} = \"{sceneName}\";");
                            sb.AppendLine();
                        }
                        buildIndex++;
                    }
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                File.WriteAllText(outputPath, sb.ToString());

                // Refresh asset database if the file is within Assets folder
                if (outputPath.StartsWith(Application.dataPath))
                {
                    AssetDatabase.Refresh();
                }

                Debug.Log($"Scene definitions exported successfully to: {outputPath}");
            }
            catch (System.Exception e)
            {
                Debug.LogError($"Failed to export scene definitions: {e.Message}");
            }
        }

        private static string MakeValidIdentifier(string input)
        {
            if (string.IsNullOrEmpty(input))
                return "UnnamedScene";

            StringBuilder sb = new StringBuilder();

            // First character must be letter or underscore
            char firstChar = input[0];
            if (char.IsLetter(firstChar) || firstChar == '_')
            {
                sb.Append(firstChar);
            }
            else
            {
                sb.Append('_');
                if (char.IsDigit(firstChar))
                    sb.Append(firstChar);
            }

            // Remaining characters can be letters, digits, or underscores
            for (int i = 1; i < input.Length; i++)
            {
                char c = input[i];
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    sb.Append(c);
                }
                else
                {
                    sb.Append('_');
                }
            }

            string result = sb.ToString();

            // Avoid C# keywords
            if (IsCSharpKeyword(result))
            {
                result = "@" + result;
            }

            return result;
        }

        private static bool IsCSharpKeyword(string identifier)
        {
            string[] keywords = {
                "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
                "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
                "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
                "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
                "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
                "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
                "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this",
                "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
                "using", "virtual", "void", "volatile", "while"
            };

            return System.Array.IndexOf(keywords, identifier.ToLower()) >= 0;
        }
    }
}
